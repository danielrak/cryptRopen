---
title: "flat_crypt_r.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# crypt_r

```{r development-crypt_r}
# Prepare the code of your function here
crypt_r(mask_folder_path = "I:/Mon Drive/Projects/cryptRopti/msq_tests", 
        mask_file = "msq_valid.xlsx", 
        output_path = "I:/Mon Drive/Projects/cryptRopti/msq_tests", 
        intermediate_path = "I:/Mon Drive/Projects/cryptRopti/msq_tests", 
        encryption_key = "123456")
```

```{r function-crypt_r}
#' Industrialized dataset variables encryption.
#'
#' This function consolidates a set of procedures
#' made to encrypt variables from datasets.
#' Variables to encrypt and input datasets can be in any number,
#' following user's needs.
#' The design tries to approach parallel processing.
#'
#' @param mask_folder_path Folder path of the excel mask.
#' @param mask_file File name (with extension) of the excel mask.
#' @param output_path Folder path where the encrypted datasets
#' will be created.
#' @param intermediate_path Folder path where intermediate files
#' (correspondence tables for e.g) will be created.
#' @param encryption_key Character vector.
#' @param algorithm Algorithm to use.
#' From digest::digest()'s algo argument.
#' @param correspondence_table Logical vector. If TRUE, the correspondence tables will computed
#' and stored in the indicated intermediate_path.
#' @importFrom magrittr %>%
#' @export
#'
crypt_r <- function (mask_folder_path, mask_file,
                     output_path, intermediate_path,
                     encryption_key, algorithm = "md5",
                     correspondence_table = TRUE) {

  requireNamespace("magrittr")

  # The Excel mask:
  mask <-
    rio::import(file.path(mask_folder_path, mask_file)) %>%

    # Without eventual blank lines in the mask (for visualization ease):
    dplyr::filter_all(dplyr::any_vars(! is.na(.))) %>%

    # Inserting a row_number (useful for technical reasons):
    dplyr::mutate(row_number = dplyr::row_number()) %>%

    # Keep only lines on datasets the user want to encrypt:
    dplyr::filter(to_encrypt == "X")

  # Check eventual duplicated file names, if there is, add indication
  # to keep file names unique:
  mask <-

    dplyr::mutate(
      mask,
      dupl_encrypted_file = duplicated(encrypted_file),
      ndupl_encrypted_file = cumsum(dupl_encrypted_file) %>%
        (\(n) paste0("DUPL", n)),
      encrypted_file =
        ifelse(dupl_encrypted_file,
               paste0(ndupl_encrypted_file, "_",
                      encrypted_file),
               encrypted_file))

  # Split the maks with r rows into a list of r elements:
  split_mask <-
    split(mask, mask$row_number) %>%
    stats::setNames(paste0(mask$folder_path, "/", mask$file))

  # For each element of the list mentioned above, a set of operations.
  # (1) Import the dataset.
  # (2) Encrypt indicated variables with inputted parameters.
  # (3) Compute correspondence table between original and encrypted variables.
  # if applicable.
  # (5) Remove original variables from output.
  # (6) Write output as stated by user.
  split_mask %>%
    (\(l)
      purrr::map(names(l), \(x) {

        requireNamespace("magrittr")

        # "Sinking" necessary objects to let job({}) use them:
        mask_folder_path <- mask_folder_path
        mask_file <- mask_file
        output_path <- output_path
        intermediate_path <- intermediate_path
        encryption_key <- encryption_key
        algorithm <- algorithm
        correspondence_table <- correspondence_table

        # inspect <- inspect
        split_mask <- split_mask
        sm <- split_mask[[x]]

        job::job({
          try({
            # Import and clean:
            assign_to_global(
              sm[["encrypted_file"]] %>% stringr::str_remove("\\..*$"),
              rio::import(x) %>%
                # 0-length values into NAs:
                dplyr::mutate_if(is.character, \(x0) {
                  x0[nchar(stringr::str_trim(x0)) == 0] <- NA ;
                  stringr::str_trim(x0)
                }) %>%
                # Encrypt:
                (\(x3) {

                  # Each variable to encrypt in a vector:
                  vars_to_encrypt <- sm[["vars_to_encrypt"]] %>%
                    stringr::str_split(",") %>% unlist %>%
                    stringr::str_trim()

                  purrr::map(vars_to_encrypt, \(v) {

                    requireNamespace("magrittr")

                    # Necessary sinking:
                    mask_folder_path <- mask_folder_path
                    mask_file <- mask_file
                    output_path <- output_path
                    intermediate_path <- intermediate_path
                    encryption_key <- encryption_key
                    algorithm <- algorithm

                    # inspect <- inspect
                    split_mask <- split_mask

                    # Encryption algorithm using the digest:: package:
                    assign_to_global(paste0(v, "_crypt"),
                           crypt_vector(vector = x3[[v]], 
                                        key = encryption_key, 
                                        algo = algorithm),
                           pos = globalenv())
                  })

                  # Fuse initial dataset and encrypted variables:
                  assign_to_global(
                    sm[["encrypted_file"]] %>%
                      stringr::str_remove("\\..*$"),
                    dplyr::bind_cols(
                        purrr::map(vars_to_encrypt %>%
                                     paste0("_crypt"), get) %>%
                          do.call(what = dplyr::bind_cols) %>%
                          stats::setNames(vars_to_encrypt %>%
                                            paste0("_crypt")), 
                        x3) %>%
                      dplyr::as_tibble() %>%

                      # Correspondence table:
                      (\(d) {
                        if (! correspondence_table) {d} else {
                          purrr::map(vars_to_encrypt, \(v2) {
                            assign_to_global(
                              sm[["encrypted_file"]] %>%
                                stringr::str_remove("\\..*$") %>%
                                (\(x4) paste0("tc_", x4)),
                              dplyr::select(d,
                                            vars_to_encrypt) %>%
                                dplyr::bind_cols(
                                  purrr::map(
                                    vars_to_encrypt %>%
                                      paste0("_crypt"), get) %>%
                                    do.call(
                                      what = dplyr::bind_cols) %>%
                                    stats::setNames(
                                      vars_to_encrypt %>%
                                        paste0("_crypt"))) %>%
                                dplyr::distinct(),
                              pos = globalenv()
                            )
                          })

                          # Export into intermediate folder:
                          rio::export(
                            sm[["encrypted_file"]] %>%
                              stringr::str_remove("\\..*$") %>%
                              (\(x4)
                                paste0("tc_", x4)) %>% get(),

                            file.path(intermediate_path,
                                      sm[["encrypted_file"]] %>%
                                        stringr::str_remove(
                                          "\\..*$") %>%
                                        (\(x4)
                                          paste0("tc_", x4)) %>%
                                        paste0(".parquet"))
                          )
                          d
                        }
                      }) %>%

                      # Output without original variables:
                      dplyr::select(- vars_to_encrypt) %>%

                      # Without any other variables user want to remove
                      # from output, if applicable:
                      (\(dfin) {
                        vars_to_remove <- sm[["vars_to_remove"]] %>%
                          stringr::str_split(",") %>% unlist %>%
                          stringr::str_trim()

                        if (all(is.na(vars_to_remove))) {
                          dfin
                        } else {
                          dplyr::select(dfin, - vars_to_remove)
                        }
                      }),
                    pos = globalenv())
                }
                )
            )
          })
          invisible()

          # Export final output:
          try({
            rio::export(
              eval(parse(text = sm[["encrypted_file"]] %>%
                           stringr::str_remove("\\..*$"))),
              file.path(output_path,
                        sm[["encrypted_file"]]))
          })

          # Inspect final output:
          try({
            writexl::write_xlsx(
              eval(parse(text =  sm[["encrypted_file"]] %>%
                           stringr::str_remove("\\..*$"))) %>%
                (\(g)
                  inspect(g) %>%
                    (\(i) rbind(c("Obs = ", nrow(g),
                                  rep("", ncol(i) - 1)),
                                c("Nvars = ", nrow(i),
                                  rep("", ncol(i) - 1)),
                                cbind(1:nrow(i), i)))),
              file.path(output_path,
                        paste0("inspect_", sm[["encrypted_file"]],
                               ".xlsx"))
            )
          })
          job::export("none")
        },
        title = paste0("Encryption of ",
                       x %>% strsplit("/") %>%
                         purrr::map(\(xx) xx[length(xx)]) %>%
                         unlist()))
      }))
}
```

```{r examples-crypt_r}

```

```{r tests-crypt_r}
test_that("crypt_r works", {
  expect_true(inherits(crypt_r, "function"))
})
```

```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_crypt_r.Rmd", vignette_name = NA)
```
