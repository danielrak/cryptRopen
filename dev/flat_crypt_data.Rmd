---
title: "flat_crypt_data.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# crypt_data

```{r development-crypt_data}
# Prepare the code of your function here
```

```{r function-crypt_data}
#' Encrypt variables within a data frame
#'
#' This function corresponds to the
#' in-session version of the encryption process.
#' For the considered loaded dataset, variables to encrypt can be
#' in any number, following users's needs.
#'
#' @param loaded_dataset The dataset for which user wants
#' to encrypt at least one variable.
#' It must be an expression and not a character vector.
#' @param vars_to_encrypt Character vector of variables to encrypt.
#' @param vars_to_remove Character vector of variables to remove.
#' @param encryption_key Character vector.
#' @param algorithm Algorithm to use.
#' From digest::digest()'s algo argument.
#' @param correspondence_table Logical 1L. TRUE if user wants a correspondence table
#' between initial and encrypted values.
#' @param correspondence_table_label Character 1L. Label of the correspondence table.
#' @seealso cryptR::crypt_r(), digest::digest().
#' @importFrom magrittr  %>%
#' @export
#'
crypt_data <- function(loaded_dataset,
                       vars_to_encrypt,
                       vars_to_remove = NULL,
                       encryption_key,
                       algorithm = "md5",
                       correspondence_table = TRUE,
                       correspondence_table_label = NULL
) {
  # First checks:
  vars <- names(loaded_dataset)
  
  if (! all(vars_to_encrypt %in% vars)) {
    stop("All indicated vars_to_encrypt must be effectively a variable name.")
  }
  
  if (! is.null(vars_to_remove) &
      ! all(vars_to_remove %in% vars)) {
    stop("All indicated vars_to_remove must be effectively a variable name.")
  }
  
  if (correspondence_table &
      is.null(correspondence_table_label)) {
    stop("If the correspondence_table arg is TRUE, correspondence_table_label must be indicated.")
  }
  
  # Clean:
  loaded_dataset <- loaded_dataset %>%
    dplyr::mutate_if(is.character, \(x0) {
      x0[nchar(stringr::str_trim(x0)) == 0] <- NA ;
      stringr::str_trim(x0)
    })
  
  # Encrypt:
  vars_to_encrypt <- stringr::str_trim(vars_to_encrypt)
  
  encrypted_data <- purrr::map(
    vars_to_encrypt, \(x) 
    crypt_vector(loaded_dataset[[x]], key = encryption_key, 
                 algo = algorithm)
  )
  encrypted_data <- do.call(what = cbind, encrypted_data)
  encrypted_data <- as.data.frame(encrypted_data)
  colnames(encrypted_data) <- paste0(vars_to_encrypt, "_crypt")
  
  if (any(duplicated(c(names(encrypted_data), names(loaded_dataset))))) {
    
    dedupl_char_values <- function (x) {
      u <- unique(x[duplicated(x)])
      l <- lapply(u, function (d) which(x == d))
      l <- stats::setNames(l, u)
      l <- lapply(l, \(v) {
        v1 <- v[2:length(v)]
        v2 <- 1:length(v1)
      })
      l <- lapply(names(l), \(n) {
        w <- which(x == n)
        w <- w[2:length(w)]
        x[w] <- paste0(x[w], "_dupl", l[[n]])
        x
      })
      l <- do.call(what = rbind, l)
      l <- apply(l, 2, \(r) {
        if (length(unique(r)) == 1) {unique(r)} 
        else {r[grep("dupl", r)]}
      })
      l
    }
    
    namestot <- c(names(encrypted_data), names(loaded_dataset))
    namestot_dedupl <- dedupl_char_values(namestot)
    names(loaded_dataset) <- namestot_dedupl[
      (length(names(encrypted_data)) + 1):length(namestot_dedupl)]
  }
  
  encrypted_data <- cbind(encrypted_data, loaded_dataset)
  
  # Correspondence table:
  if (correspondence_table) {
    
    assign_to_global(paste0("tc_crypt_", correspondence_table_label),
           dplyr::select(encrypted_data,
                         vars_to_encrypt,
                         paste0(vars_to_encrypt, "_crypt")),
           pos = globalenv())
  }
  
  # Output without original variables and additional variables to remove:
  if (! is.null(vars_to_remove)) {
    encrypted_data <- dplyr::select(
      encrypted_data,
      - vars_to_encrypt,
      - vars_to_remove
    )
  } else {
    encrypted_data <- dplyr::select(
      encrypted_data,
      - vars_to_encrypt
    )
  }
  
  encrypted_data
}
```

```{r examples-crypt_data}
crypt_data(
  loaded_dataset = mtcars[1:5, ], 
  vars_to_encrypt = "mpg", 
  vars_to_remove = "cyl", 
  encryption_key = "1234567", 
  algorithm = "md5", 
  correspondence_table = FALSE
)
```

```{r tests-crypt_data}
test_that("Valid outputs are consistent", {
  
  output <- structure(list(
    mpg_crypt = c("CEA9D4F43791ACE22D90EDBF6CE405F5", 
                  "CEA9D4F43791ACE22D90EDBF6CE405F5", 
                  "65080BE2078D5C5934F018F806E72E81", 
                  "18C5941010E3CDCB669F472DF3A1DD5E", 
                  "1866EA523631A281BD9431915F7C407F"), 
    disp = c(160, 160, 108, 258, 360), 
    hp = c(110, 110, 93, 110, 175), 
    drat = c(3.9, 3.9, 3.85, 3.08, 3.15), 
    wt = c(2.62, 2.875, 2.32, 3.215, 3.44), 
    qsec = c(16.46, 17.02, 18.61, 19.44, 17.02), 
    vs = c(0, 0, 1, 1, 0), 
    am = c(1, 1, 1, 0, 0), 
    gear = c(4, 4, 4, 3, 3), 
    carb = c(4, 4, 1, 1, 2)), 
    class = "data.frame", 
    row.names = c("Mazda RX4", "Mazda RX4 Wag", "Datsun 710", 
                  "Hornet 4 Drive", "Hornet Sportabout"))
  
  expect_identical(object = output, 
                   expected = crypt_data(
                     loaded_dataset = mtcars[1:5, ], 
                     vars_to_encrypt = "mpg", 
                     vars_to_remove = "cyl", 
                     encryption_key = "1234567", 
                     algorithm = "md5", 
                     correspondence_table = FALSE
                   ))
})

test_that("Errors are consistent", {
  
  expect_error(
    object = crypt_data(loaded_dataset = mtcars[1:5], 
                        vars_to_encrypt = "noexist", 
                        vars_to_remove = "cyl", 
                        encryption_key = "123456", 
                        algorithm = "md5", 
                        correspondence_table = FALSE),
    regexp = "All indicated vars_to_encrypt must be effectively a variable name."
  )
  
  expect_error(
    object = crypt_data(loaded_dataset = mtcars[1:5], 
                        vars_to_encrypt = "mpg", 
                        vars_to_remove = "noexist", 
                        encryption_key = "123456", 
                        algorithm = "md5", 
                        correspondence_table = FALSE),
    regexp = "All indicated vars_to_remove must be effectively a variable name."
  )
})
```


```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_crypt_data.Rmd", 
               vignette_name = NA)
```

